#!/usr/bin/env python3
"""
Integra√ß√£o do Sistema de Gatilhos para Produ√ß√£o
Conecta o sistema de gatilhos ao bot principal do Ghost Bot
"""
import sys
import os
import logging
from pathlib import Path
from typing import Optional, Tuple

# Adicionar diret√≥rio principal ao path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Configurar logging espec√≠fico para produ√ß√£o
logger = logging.getLogger('production_integration')

def setup_trigger_integration(application):
    """
    Configura a integra√ß√£o do sistema de gatilhos para produ√ß√£o
    
    Args:
        application: Inst√¢ncia da aplica√ß√£o do bot Telegram
        
    Returns:
        Tuple[Optional[object], Optional[object]]: (integrator, ui_implementation)
    """
    try:
        logger.info("üöÄ Iniciando integra√ß√£o do sistema de gatilhos para produ√ß√£o...")
        
        # Importar componentes do sistema de gatilhos
        from trigger import (
            trigger_system, 
            TriggerEvent, 
            OrderStatus,
            BotTriggerIntegrator,
            TriggerUIImplementation,
            LightningHandler,
            SmartPixMonitor
        )
        
        logger.info("‚úÖ M√≥dulos do sistema de gatilhos importados com sucesso")
        
        # Criar inst√¢ncia do integrador de bot
        logger.info("üîß Criando integrador de bot...")
        integrator = ProductionBotIntegrator(application, trigger_system)
        
        # Criar implementa√ß√£o da interface do usu√°rio
        logger.info("üé® Criando implementa√ß√£o da interface...")
        ui_implementation = ProductionTriggerUI(application)
        
        # Ativar Smart PIX Monitor
        logger.info("üí∞ Ativando Smart PIX Monitor...")
        pix_monitor = SmartPixMonitor()
        pix_monitor.start_monitoring()
        
        # Ativar Lightning Handler
        logger.info("‚ö° Ativando Lightning Handler...")
        lightning_handler = LightningHandler()
        
        # Configurar handlers espec√≠ficos para produ√ß√£o
        setup_production_handlers(application, integrator, ui_implementation)
        
        logger.info("‚úÖ Sistema de gatilhos integrado com sucesso para produ√ß√£o!")
        
        return integrator, ui_implementation
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao configurar integra√ß√£o de gatilhos: {e}", exc_info=True)
        return None, None

def setup_production_handlers(application, integrator, ui_implementation):
    """
    Configura handlers espec√≠ficos para produ√ß√£o
    
    Args:
        application: Inst√¢ncia da aplica√ß√£o do bot
        integrator: Integrador de bot
        ui_implementation: Implementa√ß√£o da interface
    """
    try:
        from telegram.ext import CommandHandler, CallbackQueryHandler, MessageHandler, filters
        from trigger import TriggerEvent, trigger_system
        
        # Handler para comando /comprar (substitui menu antigo)
        async def handle_comprar_command(update, context):
            chat_id = str(update.effective_chat.id)
            logger.info(f"üõí Comando /comprar recebido de {chat_id}")
            
            # Disparar evento de compra no sistema de gatilhos
            trigger_system.trigger_event(
                TriggerEvent.USER_CLICKED_BUY, 
                chat_id
            )
        
        # Handler para sele√ß√£o de moeda
        async def handle_currency_selection(update, context):
            query = update.callback_query
            await query.answer()
            
            chat_id = str(query.message.chat.id)
            currency = query.data.replace('currency_', '')
            
            logger.info(f"üí∞ Moeda selecionada: {currency} por {chat_id}")
            
            # Disparar evento de sele√ß√£o de moeda
            trigger_system.trigger_event(
                TriggerEvent.CURRENCY_SELECTED,
                chat_id,
                {'currency': currency}
            )
        
        # Handler para sele√ß√£o de rede
        async def handle_network_selection(update, context):
            query = update.callback_query
            await query.answer()
            
            chat_id = str(query.message.chat.id)
            network = query.data.replace('network_', '')
            
            logger.info(f"üåê Rede selecionada: {network} por {chat_id}")
            
            # Disparar evento de sele√ß√£o de rede
            trigger_system.trigger_event(
                TriggerEvent.NETWORK_SELECTED,
                chat_id,
                {'network': network}
            )
        
        # Handler para sele√ß√£o de m√©todo de pagamento
        async def handle_payment_method_selection(update, context):
            query = update.callback_query
            await query.answer()
            
            chat_id = str(query.message.chat.id)
            payment_method = query.data.replace('payment_', '')
            
            logger.info(f"üí≥ M√©todo de pagamento: {payment_method} por {chat_id}")
            
            # Disparar evento de m√©todo de pagamento
            trigger_system.trigger_event(
                TriggerEvent.PAYMENT_METHOD_SELECTED,
                chat_id,
                {'payment_method': payment_method}
            )
        
        # Handler para entrada de valor
        async def handle_amount_input(update, context):
            chat_id = str(update.effective_chat.id)
            message_text = update.message.text
            
            # Verificar se o usu√°rio est√° esperando por valor
            if integrator.is_waiting_for_amount(chat_id):
                try:
                    # Tentar converter para float
                    amount_text = message_text.replace(',', '.')
                    amount = float(amount_text)
                    
                    logger.info(f"üíµ Valor informado: R$ {amount} por {chat_id}")
                    
                    # Disparar evento de valor
                    trigger_system.trigger_event(
                        TriggerEvent.AMOUNT_ENTERED,
                        chat_id,
                        {'amount': amount}
                    )
                    
                except ValueError:
                    await update.message.reply_text(
                        "‚ùå Valor inv√°lido. Digite um n√∫mero v√°lido (ex: 50.00)"
                    )
        
        # Handler para entrada de endere√ßo
        async def handle_address_input(update, context):
            chat_id = str(update.effective_chat.id)
            address = update.message.text.strip()
            
            # Verificar se o usu√°rio est√° esperando por endere√ßo
            if integrator.is_waiting_for_address(chat_id):
                logger.info(f"üìÆ Endere√ßo informado por {chat_id}: {address}")
                
                # Disparar evento de endere√ßo fornecido
                trigger_system.trigger_event(
                    TriggerEvent.ADDRESS_PROVIDED,
                    chat_id,
                    {'address': address}
                )
        
        # Adicionar handlers √† aplica√ß√£o
        application.add_handler(CommandHandler('comprar', handle_comprar_command))
        application.add_handler(CallbackQueryHandler(handle_currency_selection, pattern='^currency_'))
        application.add_handler(CallbackQueryHandler(handle_network_selection, pattern='^network_'))
        application.add_handler(CallbackQueryHandler(handle_payment_method_selection, pattern='^payment_'))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_amount_input))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_address_input))
        
        logger.info("‚úÖ Handlers de produ√ß√£o configurados com sucesso!")
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao configurar handlers de produ√ß√£o: {e}", exc_info=True)

class ProductionBotIntegrator:
    """Integrador do bot para produ√ß√£o"""
    
    def __init__(self, application, trigger_system):
        self.application = application
        self.trigger_system = trigger_system
        self.logger = logger
        
    def is_waiting_for_amount(self, chat_id: str) -> bool:
        """Verifica se o usu√°rio deve informar valor"""
        order = self.trigger_system.active_orders.get(chat_id)
        return order and order.get('status') == 'NETWORK_SELECTED'
    
    def is_waiting_for_address(self, chat_id: str) -> bool:
        """Verifica se o usu√°rio deve informar endere√ßo"""
        order = self.trigger_system.active_orders.get(chat_id)
        return order and order.get('status') == 'PIX_PAID'

class ProductionTriggerUI:
    """Implementa√ß√£o da interface do usu√°rio para produ√ß√£o"""
    
    def __init__(self, application):
        self.application = application
        self.logger = logger
        
        # Sobrescrever m√©todos de interface do sistema de gatilhos
        from trigger import trigger_system
        trigger_system.send_currency_selection_menu = self.send_currency_selection_menu
        trigger_system.send_network_selection_menu = self.send_network_selection_menu
        trigger_system.send_amount_request = self.send_amount_request
        trigger_system.send_order_summary_and_payment_options = self.send_order_summary_and_payment_options
        trigger_system.send_pix_qr_code = self.send_pix_qr_code
        trigger_system.send_transaction_completed_message = self.send_transaction_completed_message
        trigger_system.send_invalid_amount_message = self.send_invalid_amount_message
        
    async def send_currency_selection_menu(self, chat_id: str):
        """Envia menu de sele√ß√£o de moeda"""
        from telegram import InlineKeyboardMarkup, InlineKeyboardButton
        
        markup = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("‚Çø Bitcoin", callback_data="currency_bitcoin"),
                InlineKeyboardButton("‚ÇÆ Tether (USDT)", callback_data="currency_tether")
            ],
            [
                InlineKeyboardButton("üí∞ DEPIX", callback_data="currency_depix")
            ]
        ])
        
        await self.application.bot.send_message(
            chat_id=chat_id,
            text="üí∞ <b>Escolha a criptomoeda:</b>\n\n"
                 "‚Ä¢ <b>Bitcoin (BTC)</b> - A primeira e maior criptomoeda\n"
                 "‚Ä¢ <b>Tether (USDT)</b> - Stablecoin pareada ao d√≥lar\n"
                 "‚Ä¢ <b>DEPIX</b> - Token nativo brasileiro",
            reply_markup=markup,
            parse_mode='HTML'
        )
    
    async def send_network_selection_menu(self, chat_id: str, currency: str):
        """Envia menu de sele√ß√£o de rede"""
        from telegram import InlineKeyboardMarkup, InlineKeyboardButton
        
        markup = InlineKeyboardMarkup()
        
        if currency == 'bitcoin':
            markup.inline_keyboard = [
                [
                    InlineKeyboardButton("‚ö° Lightning", callback_data="network_lightning"),
                    InlineKeyboardButton("üîó On-chain", callback_data="network_onchain")
                ],
                [
                    InlineKeyboardButton("üåä Liquid", callback_data="network_liquid")
                ]
            ]
        elif currency == 'tether':
            markup.inline_keyboard = [
                [
                    InlineKeyboardButton("üî∑ Polygon", callback_data="network_polygon"),
                    InlineKeyboardButton("üåä Liquid", callback_data="network_liquid")
                ]
            ]
        elif currency == 'depix':
            markup.inline_keyboard = [
                [
                    InlineKeyboardButton("üî∑ Polygon", callback_data="network_polygon")
                ]
            ]
        
        networks_info = {
            'bitcoin': "‚ö° Lightning - Instant√¢neo e baixo custo\nüîó On-chain - Rede principal\nüåä Liquid - Sidechain r√°pida",
            'tether': "üî∑ Polygon - Rede r√°pida e barata\nüåä Liquid - Sidechain do Bitcoin",
            'depix': "üî∑ Polygon - Rede nativa do DEPIX"
        }
        
        info_text = f"üåê <b>Escolha a rede para {currency.upper()}:</b>\n\n{networks_info.get(currency, '')}"
        
        await self.application.bot.send_message(
            chat_id=chat_id,
            text=info_text,
            reply_markup=markup,
            parse_mode='HTML'
        )
    
    async def send_amount_request(self, chat_id: str):
        """Solicita valor do usu√°rio"""
        await self.application.bot.send_message(
            chat_id=chat_id,
            text="üíµ <b>Informe o valor da compra:</b>\n\n"
                 "‚Ä¢ Valor m√≠nimo: R$ 10,00\n"
                 "‚Ä¢ Valor m√°ximo: R$ 4.999,99\n"
                 "‚Ä¢ Formato: 50.00 ou 50,00\n\n"
                 "üí° Digite o valor desejado:",
            parse_mode='HTML'
        )
    
    async def send_order_summary_and_payment_options(self, chat_id: str, order: dict):
        """Envia resumo do pedido e op√ß√µes de pagamento"""
        from telegram import InlineKeyboardMarkup, InlineKeyboardButton
        
        currency = order['currency'].upper()
        network = order['network'].upper() if order['network'] else 'N/A'
        amount = order['amount']
        
        # Calcular cota√ß√£o aproximada
        crypto_amount = self.calculate_crypto_amount(order)
        
        summary_text = (
            f"üìã <b>RESUMO DO PEDIDO</b>\n\n"
            f"üí∞ Moeda: {currency}\n"
            f"üåê Rede: {network}\n"
            f"üíµ Valor: R$ {amount:.2f}\n"
            f"‚ö° Voc√™ receber√°: ~{crypto_amount}\n\n"
            f"üí≥ <b>Escolha o m√©todo de pagamento:</b>"
        )
        
        markup = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üì± PIX (Recomendado)", callback_data="payment_PIX")
            ],
            [
                InlineKeyboardButton("üè¶ TED", callback_data="payment_TED"),
                InlineKeyboardButton("üìÑ Boleto", callback_data="payment_BOLETO")
            ]
        ])
        
        await self.application.bot.send_message(
            chat_id=chat_id,
            text=summary_text,
            reply_markup=markup,
            parse_mode='HTML'
        )
    
    async def send_pix_qr_code(self, chat_id: str, pix_data: dict):
        """Envia QR Code PIX"""
        qr_text = (
            f"üì± <b>PAGAMENTO PIX GERADO</b>\n\n"
            f"üéØ ID do Pedido: <code>{pix_data['depix_id']}</code>\n"
            f"üí∞ Valor: R$ {pix_data.get('amount', '5.00')}\n\n"
            f"üìã <b>Para pagar:</b>\n"
            f"1. Abra seu app banc√°rio\n"
            f"2. Escaneie o QR Code abaixo\n"
            f"3. Ou use o c√≥digo Pix Copia e Cola\n\n"
            f"‚è∞ O pagamento ser√° detectado automaticamente!\n"
            f"üí° Ap√≥s o pagamento, voc√™ receber√° uma mensagem solicitando seu endere√ßo."
        )
        
        await self.application.bot.send_message(
            chat_id=chat_id,
            text=qr_text,
            parse_mode='HTML'
        )
        
        # Enviar c√≥digo Pix Copia e Cola
        await self.application.bot.send_message(
            chat_id=chat_id,
            text=f"üìã <b>PIX Copia e Cola:</b>\n\n"
                 f"<code>{pix_data.get('copy_paste', 'PIX_CODE_HERE')}</code>\n\n"
                 f"üëÜ Toque para copiar",
            parse_mode='HTML'
        )
    
    async def send_transaction_completed_message(self, chat_id: str, result: dict):
        """Envia mensagem de transa√ß√£o conclu√≠da"""
        success_text = (
            f"üéâ <b>TRANSA√á√ÉO CONCLU√çDA!</b>\n\n"
            f"‚úÖ Sua criptomoeda foi enviada com sucesso!\n\n"
            f"üîó <b>ID da Transa√ß√£o:</b>\n"
            f"<code>{result.get('txid', 'TX_ID_HERE')}</code>\n\n"
            f"üí° <b>Confira na sua carteira!</b>\n"
            f"A transa√ß√£o pode levar alguns minutos para aparecer.\n\n"
            f"üì± Para nova compra, use /comprar novamente."
        )
        
        await self.application.bot.send_message(
            chat_id=chat_id,
            text=success_text,
            parse_mode='HTML'
        )
    
    async def send_invalid_amount_message(self, chat_id: str):
        """Envia mensagem de valor inv√°lido"""
        await self.application.bot.send_message(
            chat_id=chat_id,
            text="‚ùå <b>Valor inv√°lido!</b>\n\n"
                 "üíµ O valor deve estar entre:\n"
                 "‚Ä¢ M√≠nimo: R$ 10,00\n"
                 "‚Ä¢ M√°ximo: R$ 4.999,99\n\n"
                 "üí° Digite um valor v√°lido:",
            parse_mode='HTML'
        )
    
    def calculate_crypto_amount(self, order: dict) -> str:
        """Calcula quantidade aproximada de crypto"""
        currency = order['currency']
        amount = order['amount']
        
        # Cota√ß√µes simuladas para c√°lculo aproximado
        rates = {
            'bitcoin': 300000,  # R$ 300k por BTC
            'tether': 5.5,      # R$ 5,50 por USDT
            'depix': 1.0        # R$ 1,00 por DEPIX
        }
        
        rate = rates.get(currency, 1.0)
        crypto_amount = amount / rate
        
        if currency == 'bitcoin':
            if order.get('network') == 'lightning':
                sats = int(crypto_amount * 100000000)
                return f"{sats} sats"
            else:
                return f"{crypto_amount:.8f} BTC"
        elif currency == 'tether':
            return f"{crypto_amount:.2f} USDT"
        elif currency == 'depix':
            return f"{crypto_amount:.2f} DEPIX"
        
        return "N/A"

if __name__ == "__main__":
    print("‚úÖ M√≥dulo de integra√ß√£o de produ√ß√£o carregado!")
    print("üí° Use setup_trigger_integration(application) para ativar")
