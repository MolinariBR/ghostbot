#!/usr/bin/env python3
"""
Integrador: Sistema de Gatilhos + Bot Telegram
Conecta o sistema de gatilhos event-driven com o bot atual do Telegram
"""
import sys
import os
import logging
import json
from pathlib import Path

# Adicionar diret√≥rio principal ao path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Importar sistema de gatilhos
try:
    from .sistema_gatilhos import trigger_system, TriggerEvent
except ImportError:
    try:
        from trigger.sistema_gatilhos import trigger_system, TriggerEvent
    except ImportError:
        # Fallback para sistema simplificado
        from trigger.simple_system import simple_trigger_system as trigger_system
        from trigger.config import TriggerEvent

# Importar bot
try:
    from bot import bot
except ImportError:
    print("AVISO: bot n√£o encontrado, usando mock")
    bot = None

# Importar classes do Telegram
try:
    from telegram import InlineKeyboardMarkup, InlineKeyboardButton
except ImportError:
    try:
        from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
    except ImportError:
        # Mock das classes se nenhuma estiver dispon√≠vel
        class InlineKeyboardMarkup:
            def __init__(self):
                pass
            def row(self, *args):
                pass
        
        class InlineKeyboardButton:
            def __init__(self, text, callback_data=None):
                self.text = text
                self.callback_data = callback_data

logger = logging.getLogger('integrador_bot')

class BotTriggerIntegrator:
    """Integra sistema de gatilhos com bot do Telegram"""
    
    def __init__(self, bot_instance, trigger_system_instance):
        self.bot = bot_instance
        self.trigger_system = trigger_system_instance
        self.setup_handlers()
    
    def setup_handlers(self):
        """Configura handlers do bot para disparar eventos"""
        
        # Handler para comando /comprar
        @self.bot.message_handler(commands=['comprar'])
        def handle_buy_command(message):
            chat_id = str(message.chat.id)
            logger.info(f"üõí Comando /comprar recebido de {chat_id}")
            
            # Disparar evento de compra
            self.trigger_system.trigger_event(
                TriggerEvent.USER_CLICKED_BUY, 
                chat_id
            )
        
        # Handler para sele√ß√£o de moeda
        @self.bot.callback_query_handler(func=lambda call: call.data.startswith('currency_'))
        def handle_currency_selection(call):
            chat_id = str(call.message.chat.id)
            currency = call.data.replace('currency_', '')
            
            logger.info(f"üí∞ Moeda selecionada: {currency} por {chat_id}")
            
            # Disparar evento de sele√ß√£o de moeda
            self.trigger_system.trigger_event(
                TriggerEvent.CURRENCY_SELECTED,
                chat_id,
                {'currency': currency}
            )
            
            # Editar mensagem
            self.bot.edit_message_text(
                f"‚úÖ Moeda selecionada: {currency.upper()}",
                chat_id=call.message.chat.id,
                message_id=call.message.message_id
            )
        
        # Handler para sele√ß√£o de rede
        @self.bot.callback_query_handler(func=lambda call: call.data.startswith('network_'))
        def handle_network_selection(call):
            chat_id = str(call.message.chat.id)
            network = call.data.replace('network_', '')
            
            logger.info(f"üåê Rede selecionada: {network} por {chat_id}")
            
            # Disparar evento de sele√ß√£o de rede
            self.trigger_system.trigger_event(
                TriggerEvent.NETWORK_SELECTED,
                chat_id,
                {'network': network}
            )
            
            # Editar mensagem
            self.bot.edit_message_text(
                f"‚úÖ Rede selecionada: {network.upper()}",
                chat_id=call.message.chat.id,
                message_id=call.message.message_id
            )
        
        # Handler para valores
        @self.bot.message_handler(func=lambda message: self.is_waiting_for_amount(message))
        def handle_amount_input(message):
            chat_id = str(message.chat.id)
            
            try:
                # Tentar converter para float
                amount_text = message.text.replace(',', '.')
                amount = float(amount_text)
                
                logger.info(f"üíµ Valor informado: R$ {amount} por {chat_id}")
                
                # Disparar evento de valor
                self.trigger_system.trigger_event(
                    TriggerEvent.AMOUNT_ENTERED,
                    chat_id,
                    {'amount': amount}
                )
                
            except ValueError:
                self.bot.send_message(
                    chat_id,
                    "‚ùå Valor inv√°lido. Digite um n√∫mero v√°lido (ex: 50.00)"
                )
        
        # Handler para sele√ß√£o de m√©todo de pagamento
        @self.bot.callback_query_handler(func=lambda call: call.data.startswith('payment_'))
        def handle_payment_method_selection(call):
            chat_id = str(call.message.chat.id)
            payment_method = call.data.replace('payment_', '')
            
            logger.info(f"üí≥ M√©todo de pagamento: {payment_method} por {chat_id}")
            
            # Disparar evento de m√©todo de pagamento
            self.trigger_system.trigger_event(
                TriggerEvent.PAYMENT_METHOD_SELECTED,
                chat_id,
                {'payment_method': payment_method}
            )
            
            # Editar mensagem
            self.bot.edit_message_text(
                f"‚úÖ M√©todo selecionado: {payment_method}",
                chat_id=call.message.chat.id,
                message_id=call.message.message_id
            )
        
        # Handler para endere√ßos Lightning/crypto
        @self.bot.message_handler(func=lambda message: self.is_waiting_for_address(message))
        def handle_address_input(message):
            chat_id = str(message.chat.id)
            address = message.text.strip()
            
            logger.info(f"üìÆ Endere√ßo informado por {chat_id}: {address}")
            
            # Disparar evento de endere√ßo fornecido
            self.trigger_system.trigger_event(
                TriggerEvent.ADDRESS_PROVIDED,
                chat_id,
                {'address': address}
            )
    
    def is_waiting_for_amount(self, message):
        """Verifica se o usu√°rio deve informar valor"""
        chat_id = str(message.chat.id)
        order = self.trigger_system.active_orders.get(chat_id)
        
        if order and order['status'] == 'NETWORK_SELECTED':
            return True
        return False
    
    def is_waiting_for_address(self, message):
        """Verifica se o usu√°rio deve informar endere√ßo"""
        chat_id = str(message.chat.id)
        order = self.trigger_system.active_orders.get(chat_id)
        
        if order and order['status'] == 'PIX_PAID':
            return True
        return False

class TriggerUIImplementation:
    """Implementa interface do usu√°rio para o sistema de gatilhos"""
    
    def __init__(self, bot_instance):
        self.bot = bot_instance
        
        # Sobrescrever m√©todos de interface do sistema de gatilhos
        trigger_system.send_currency_selection_menu = self.send_currency_selection_menu
        trigger_system.send_network_selection_menu = self.send_network_selection_menu
        trigger_system.send_amount_request = self.send_amount_request
        trigger_system.send_order_summary_and_payment_options = self.send_order_summary_and_payment_options
        trigger_system.send_pix_qr_code = self.send_pix_qr_code
        trigger_system.send_transaction_completed_message = self.send_transaction_completed_message
        trigger_system.send_invalid_amount_message = self.send_invalid_amount_message
    
    def send_currency_selection_menu(self, chat_id: str):
        """Envia menu de sele√ß√£o de moeda"""
        markup = InlineKeyboardMarkup()
        markup.row(
            InlineKeyboardButton("‚Çø Bitcoin", callback_data="currency_bitcoin"),
            InlineKeyboardButton("‚ÇÆ Tether (USDT)", callback_data="currency_tether")
        )
        markup.row(
            InlineKeyboardButton("üí∞ DEPIX", callback_data="currency_depix")
        )
        
        self.bot.send_message(
            chat_id,
            "üí∞ <b>Escolha a criptomoeda:</b>\n\n"
            "‚Ä¢ <b>Bitcoin (BTC)</b> - A primeira e maior criptomoeda\n"
            "‚Ä¢ <b>Tether (USDT)</b> - Stablecoin pareada ao d√≥lar\n"
            "‚Ä¢ <b>DEPIX</b> - Token nativo brasileiro",
            reply_markup=markup,
            parse_mode='HTML'
        )
    
    def send_network_selection_menu(self, chat_id: str, currency: str):
        """Envia menu de sele√ß√£o de rede"""
        markup = InlineKeyboardMarkup()
        
        if currency == 'bitcoin':
            markup.row(
                InlineKeyboardButton("‚ö° Lightning", callback_data="network_lightning"),
                InlineKeyboardButton("üîó On-chain", callback_data="network_onchain")
            )
            markup.row(
                InlineKeyboardButton("üåä Liquid", callback_data="network_liquid")
            )
        elif currency == 'tether':
            markup.row(
                InlineKeyboardButton("üî∑ Polygon", callback_data="network_polygon"),
                InlineKeyboardButton("üåä Liquid", callback_data="network_liquid")
            )
        elif currency == 'depix':
            markup.row(
                InlineKeyboardButton("üî∑ Polygon", callback_data="network_polygon")
            )
        
        networks_info = {
            'bitcoin': {
                'lightning': '‚ö° Lightning - Transa√ß√µes instant√¢neas e taxas baixas',
                'onchain': 'üîó On-chain - Rede principal do Bitcoin',
                'liquid': 'üåä Liquid - Sidechain r√°pida e confidencial'
            },
            'tether': {
                'polygon': 'üî∑ Polygon - Rede r√°pida e taxas baixas',
                'liquid': 'üåä Liquid - Sidechain do Bitcoin'
            },
            'depix': {
                'polygon': 'üî∑ Polygon - Rede nativa do DEPIX'
            }
        }
        
        info_text = f"üåê <b>Escolha a rede para {currency.upper()}:</b>\n\n"
        for network, description in networks_info.get(currency, {}).items():
            info_text += f"{description}\n"
        
        self.bot.send_message(
            chat_id,
            info_text,
            reply_markup=markup,
            parse_mode='HTML'
        )
    
    def send_amount_request(self, chat_id: str):
        """Solicita valor do usu√°rio"""
        self.bot.send_message(
            chat_id,
            "üíµ <b>Informe o valor da compra:</b>\n\n"
            "‚Ä¢ Valor m√≠nimo: R$ 10,00\n"
            "‚Ä¢ Valor m√°ximo: R$ 4.999,99\n"
            "‚Ä¢ Formato: 50.00 ou 50,00\n\n"
            "üí° Digite o valor desejado:",
            parse_mode='HTML'
        )
    
    def send_order_summary_and_payment_options(self, chat_id: str, order: dict):
        """Envia resumo do pedido e op√ß√µes de pagamento"""
        currency = order['currency'].upper()
        network = order['network'].upper() if order['network'] else 'N/A'
        amount = order['amount']
        
        # Calcular cota√ß√£o (simulado)
        crypto_amount = self.calculate_crypto_amount(order)
        
        summary_text = (
            f"üìã <b>RESUMO DO PEDIDO</b>\n\n"
            f"üí∞ Moeda: {currency}\n"
            f"üåê Rede: {network}\n"
            f"üíµ Valor: R$ {amount:.2f}\n"
            f"‚ö° Voc√™ receber√°: ~{crypto_amount}\n\n"
            f"üí≥ <b>Escolha o m√©todo de pagamento:</b>"
        )
        
        markup = InlineKeyboardMarkup()
        markup.row(
            InlineKeyboardButton("üì± PIX (Recomendado)", callback_data="payment_PIX")
        )
        markup.row(
            InlineKeyboardButton("üè¶ TED", callback_data="payment_TED"),
            InlineKeyboardButton("üìÑ Boleto", callback_data="payment_BOLETO")
        )
        
        self.bot.send_message(
            chat_id,
            summary_text,
            reply_markup=markup,
            parse_mode='HTML'
        )
    
    def send_pix_qr_code(self, chat_id: str, pix_data: dict):
        """Envia QR Code PIX"""
        qr_text = (
            f"üì± <b>PAGAMENTO PIX GERADO</b>\n\n"
            f"üéØ ID do Pedido: <code>{pix_data['depix_id']}</code>\n"
            f"üí∞ Valor: R$ {pix_data.get('amount', '5.00')}\n\n"
            f"üìã <b>Para pagar:</b>\n"
            f"1. Abra seu app banc√°rio\n"
            f"2. Escaneie o QR Code abaixo\n"
            f"3. Ou use o c√≥digo Pix Copia e Cola\n\n"
            f"‚è∞ O pagamento ser√° detectado automaticamente!\n"
            f"üí° Ap√≥s o pagamento, voc√™ receber√° uma mensagem solicitando seu endere√ßo."
        )
        
        # Enviar QR Code (implementar gera√ß√£o real)
        self.bot.send_message(
            chat_id,
            qr_text,
            parse_mode='HTML'
        )
        
        # Enviar c√≥digo Pix Copia e Cola
        self.bot.send_message(
            chat_id,
            f"üìã <b>PIX Copia e Cola:</b>\n\n"
            f"<code>{pix_data.get('copy_paste', 'PIX_CODE_HERE')}</code>\n\n"
            f"üëÜ Toque para copiar",
            parse_mode='HTML'
        )
    
    def send_transaction_completed_message(self, chat_id: str, result: dict):
        """Envia mensagem de transa√ß√£o conclu√≠da"""
        success_text = (
            f"üéâ <b>TRANSA√á√ÉO CONCLU√çDA!</b>\n\n"
            f"‚úÖ Sua criptomoeda foi enviada com sucesso!\n\n"
            f"üîó <b>ID da Transa√ß√£o:</b>\n"
            f"<code>{result.get('txid', 'TX_ID_HERE')}</code>\n\n"
            f"üí° <b>Confira na sua carteira!</b>\n"
            f"A transa√ß√£o pode levar alguns minutos para aparecer.\n\n"
            f"üì± Para nova compra, use /comprar novamente."
        )
        
        self.bot.send_message(
            chat_id,
            success_text,
            parse_mode='HTML'
        )
    
    def send_invalid_amount_message(self, chat_id: str):
        """Envia mensagem de valor inv√°lido"""
        self.bot.send_message(
            chat_id,
            "‚ùå <b>Valor inv√°lido!</b>\n\n"
            "üíµ O valor deve estar entre:\n"
            "‚Ä¢ M√≠nimo: R$ 10,00\n"
            "‚Ä¢ M√°ximo: R$ 4.999,99\n\n"
            "üí° Digite um valor v√°lido:",
            parse_mode='HTML'
        )
    
    def calculate_crypto_amount(self, order: dict) -> str:
        """Calcula quantidade de crypto baseada no valor em reais"""
        # Implementar c√°lculo real baseado em cota√ß√µes
        currency = order['currency']
        amount = order['amount']
        
        if currency == 'bitcoin':
            # Simular cota√ß√£o Bitcoin
            btc_rate = 300000  # R$ 300k por BTC
            btc_amount = amount / btc_rate
            if order['network'] == 'lightning':
                sats = int(btc_amount * 100000000)
                return f"{sats} sats"
            else:
                return f"{btc_amount:.8f} BTC"
        elif currency == 'tether':
            # Simular cota√ß√£o USDT
            usdt_rate = 5.5  # R$ 5,50 por USDT
            usdt_amount = amount / usdt_rate
            return f"{usdt_amount:.2f} USDT"
        elif currency == 'depix':
            # Simular cota√ß√£o DEPIX
            depix_rate = 1.0  # R$ 1,00 por DEPIX
            depix_amount = amount / depix_rate
            return f"{depix_amount:.2f} DEPIX"
        
        return "N/A"

# Fun√ß√£o para ativar o sistema integrado
def activate_trigger_system():
    """Ativa o sistema de gatilhos integrado com o bot"""
    logger.info("üöÄ Ativando sistema de gatilhos integrado...")
    
    # Integrar handlers
    integrator = BotTriggerIntegrator(bot, trigger_system)
    
    # Implementar interface
    ui_implementation = TriggerUIImplementation(bot)
    
    logger.info("‚úÖ Sistema de gatilhos ativado com sucesso!")
    
    return integrator, ui_implementation

if __name__ == "__main__":
    # Testar integra√ß√£o
    activate_trigger_system()
    print("‚úÖ Integra√ß√£o pronta para uso!")
    print("üí° Use /comprar no bot para testar o novo fluxo")
