#!/usr/bin/env python3
"""
Teste Realista Completo - Simula fluxo real de compra com integra√ß√£o Depix e Blockchain
Inclui: webhook Depix real, obten√ß√£o de TXID, monitoramento blockchain
"""

import requests
import json
import time
import sys
import os
import hashlib
import random
from datetime import datetime, timezone

# Adiciona o diret√≥rio do projeto ao path
sys.path.append('/home/mau/bot/ghost')

class TesteRealistaCompleto:
    def __init__(self):
        try:
            from tokens import Config
            self.bot_token = Config.TELEGRAM_BOT_TOKEN
            self.chat_id = "7910260237"
            self.backend_url = "https://useghost.squareweb.app"
            
            # Dados realistas do teste
            self.depix_id_real = "0197ea6c80bc7dfc81b1e02fe8d06954"
            self.valor_real = "100"  # R$ 100
            self.lightning_address_real = "bouncyflight79@walletofsatoshi.com"
            self.pedido_id = None
            self.txid_bitcoin = None
            self.teste_iniciado = datetime.now()
            
        except Exception as e:
            print(f"‚ùå Erro na inicializa√ß√£o: {e}")
            sys.exit(1)
    
    def log_passo(self, numero, titulo):
        """Log formatado para cada passo"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"\n[{timestamp}] üîß PASSO {numero}: {titulo}")
        print("-" * 70)
    
    def gerar_txid_realista(self):
        """Gera um TXID Bitcoin realista para o teste"""
        # Gera um hash SHA256 que parece um TXID real
        random_data = f"{self.depix_id_real}_{time.time()}_{random.randint(1000, 9999)}"
        txid = hashlib.sha256(random_data.encode()).hexdigest()
        return txid
    
    def criar_pedido_realista(self):
        """Cria um pedido usando o depix_id real fornecido"""
        try:
            payload = {
                "chatid": self.chat_id,
                "moeda": "BTC",
                "rede": "‚ö° Lightning",
                "amount_in_cents": int(float(self.valor_real) * 100),
                "taxa": 5.0,
                "address": self.lightning_address_real,
                "forma_pagamento": "PIX",
                "send": 0.00028571,  # Aproximadamente para R$ 100
                "user_id": int(self.chat_id),
                "depix_id": self.depix_id_real,  # USA O DEPIX_ID REAL
                "status": "pending",
                "comprovante": "Lightning Invoice"
            }
            
            headers = {'Content-Type': 'application/json'}
            response = requests.post(
                f"{self.backend_url}/rest/deposit.php",
                json=payload,
                headers=headers,
                timeout=15
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get("success") == True:
                    self.pedido_id = data.get("id")
                    print(f"‚úÖ Pedido realista criado!")
                    print(f"   üìã ID do pedido: {self.pedido_id}")
                    print(f"   üÜî Depix ID: {self.depix_id_real}")
                    print(f"   üí∞ Valor: R$ {self.valor_real}")
                    print(f"   ‚ö° Lightning Address: {self.lightning_address_real}")
                    return True
                else:
                    print(f"‚ùå Erro: {data}")
            else:
                print(f"‚ùå HTTP {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Erro: {e}")
        
        return False
    
    def simular_webhook_depix(self):
        """Simula o webhook do Depix confirmando o pagamento PIX"""
        try:
            print("üì° Simulando webhook do Depix...")
            
            # Payload que simula o que o Depix enviaria
            webhook_payload = {
                "event": "payment.confirmed",
                "data": {
                    "id": self.depix_id_real,
                    "status": "paid",
                    "amount": float(self.valor_real),
                    "currency": "BRL",
                    "confirmed_at": datetime.now(timezone.utc).isoformat(),
                    "payment_method": "pix",
                    "customer": {
                        "id": self.chat_id,
                        "email": "cliente@example.com"
                    }
                }
            }
            
            # Simula o envio para o webhook endpoint
            webhook_response = requests.post(
                f"{self.backend_url}/square_webhook.php",
                json=webhook_payload,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if webhook_response.status_code == 200:
                print(f"‚úÖ Webhook Depix simulado com sucesso!")
                print(f"   üÜî Depix ID: {self.depix_id_real}")
                print(f"   üìä Status: paid")
                print(f"   üí∞ Valor: R$ {self.valor_real}")
                print(f"   üìÖ Confirmado em: {webhook_payload['data']['confirmed_at']}")
                return True
            else:
                print(f"‚ö†Ô∏è Webhook retornou: {webhook_response.status_code}")
                return True  # Continua mesmo se webhook falhar
                
        except Exception as e:
            print(f"‚ùå Erro no webhook: {e}")
            return False
    
    def atualizar_status_pago(self):
        """Atualiza o status do pedido para 'pago' simulando processamento interno"""
        try:
            print("üí≥ Atualizando status para 'pago'...")
            
            # Simula atualiza√ß√£o interna (normalmente seria feita pelo webhook)
            # Aqui apenas informamos que o status foi atualizado
            print(f"‚úÖ Status atualizado para 'pago'")
            print(f"   üìã Pedido: {self.pedido_id}")
            print(f"   üÜî Depix ID: {self.depix_id_real}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro atualizando status: {e}")
            return False
    
    def testar_integracao_bot(self):
        """Testa se o bot detecta o pedido e solicita Lightning Address"""
        try:
            print("ü§ñ Testando integra√ß√£o com o bot...")
            
            mensagens = [
                "Status",
                "Lightning", 
                f"‚ö° {self.lightning_address_real}"
            ]
            
            for i, msg in enumerate(mensagens, 1):
                print(f"üì§ Enviando mensagem {i}: '{msg}'")
                
                payload = {
                    "chat_id": self.chat_id,
                    "text": msg
                }
                
                response = requests.post(
                    f"https://api.telegram.org/bot{self.bot_token}/sendMessage",
                    json=payload,
                    timeout=10
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('ok'):
                        msg_id = data['result']['message_id']
                        print(f"   ‚úÖ Enviada (ID: {msg_id})")
                    else:
                        print(f"   ‚ùå Erro: {data}")
                else:
                    print(f"   ‚ùå HTTP {response.status_code}")
                
                time.sleep(2)  # Pausa entre mensagens
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro testando bot: {e}")
            return False
    
    def simular_envio_bitcoin(self):
        """Simula o envio do Bitcoin com TXID real"""
        try:
            # Gera um TXID realista
            self.txid_bitcoin = self.gerar_txid_realista()
            
            print(f"üîó TXID Bitcoin gerado: {self.txid_bitcoin}")
            print("‚Çø Simulando envio Bitcoin...")
            
            # Simula atualiza√ß√£o do banco com TXID
            try:
                # Aqui seria feita a atualiza√ß√£o real no banco
                # UPDATE deposit SET blockchainTxID = ?, status = 'sent' WHERE id = ?
                pass
            except Exception as e:
                print(f"‚ö†Ô∏è Simula√ß√£o de update no banco: {e}")
            
            print(f"‚úÖ Bitcoin 'enviado' com sucesso!")
            print(f"   üîó TXID: {self.txid_bitcoin}")
            print(f"   ‚ö° Para: {self.lightning_address_real}")
            print(f"   üí∞ Valor: 0.00028571 BTC (aprox)")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro simulando envio: {e}")
            return False
    
    def verificar_txid_blockchain(self):
        """Verifica o TXID na blockchain real usando Blockstream API"""
        try:
            print("üîç Verificando TXID na blockchain real...")
            
            if not self.txid_bitcoin:
                print("‚ùå TXID n√£o dispon√≠vel")
                return False
            
            # Consulta a API Blockstream (similar ao blockchain/blockstream.php)
            url = f"https://blockstream.info/api/tx/{self.txid_bitcoin}"
            
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                tx_data = response.json()
                confirmations = tx_data.get('status', {}).get('confirmed', False)
                
                print(f"‚úÖ TXID encontrado na blockchain!")
                print(f"   üîó TXID: {self.txid_bitcoin}")
                print(f"   ‚úÖ Confirmado: {confirmations}")
                print(f"   üì¶ Block: {tx_data.get('status', {}).get('block_hash', 'N/A')}")
                
                return True
            else:
                print(f"‚ö†Ô∏è TXID n√£o encontrado na blockchain (normal para simula√ß√£o)")
                print(f"   üîó TXID simulado: {self.txid_bitcoin}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro verificando blockchain: {e}")
            return False
    
    def verificar_status_final(self):
        """Verifica o status final completo do pedido"""
        try:
            print("üìä Verificando status final do pedido...")
            
            response = requests.get(
                f"{self.backend_url}/rest/deposit.php?action=get&id={self.pedido_id}",
                timeout=15
            )
            
            if response.status_code == 200:
                data = response.json()
                
                if 'deposits' in data and len(data['deposits']) > 0:
                    pedido = data['deposits'][0]
                    
                    print(f"üìã STATUS FINAL COMPLETO:")
                    print(f"   üìã ID: {pedido.get('id')}")
                    print(f"   üÜî Depix ID: {pedido.get('depix_id')}")
                    print(f"   üí∞ Valor: R$ {pedido.get('amount_in_cents', 0)/100}")
                    print(f"   üìä Status: {pedido.get('status')}")
                    print(f"   ‚ö° Rede: {pedido.get('rede')}")
                    print(f"   üìß Lightning Address: {pedido.get('address')}")
                    print(f"   üîó Blockchain TXID: {pedido.get('blockchainTxID')}")
                    print(f"   üìÖ Criado: {pedido.get('created_at')}")
                    print(f"   ‚úÖ Notificado: {pedido.get('notified')}")
                    
                    # Verifica se o fluxo est√° completo
                    if pedido.get('blockchainTxID') and pedido.get('status') == 'sent':
                        print("üéâ FLUXO COMPLETO FINALIZADO!")
                        return True
                    else:
                        print("‚ö†Ô∏è Fluxo em andamento - alguns campos ainda n√£o preenchidos")
                        return False
                else:
                    print(f"‚ùå Pedido n√£o encontrado")
                    return False
            else:
                print(f"‚ùå HTTP {response.status_code}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro verificando status: {e}")
            return False
    
    def executar_teste_completo(self):
        """Executa o teste realista completo"""
        
        print("üöÄ INICIANDO TESTE REALISTA COMPLETO")
        print("=" * 80)
        print(f"üí∞ Valor: R$ {self.valor_real}")
        print(f"‚ö° Lightning Address: {self.lightning_address_real}")
        print(f"üÜî Depix ID (REAL): {self.depix_id_real}")
        print(f"üì± Chat ID: {self.chat_id}")
        print(f"üåê Backend: {self.backend_url}")
        print("=" * 80)
        
        # PASSO 1: Criar pedido com depix_id real
        self.log_passo(1, "Criando pedido com depix_id real")
        if not self.criar_pedido_realista():
            print("‚ùå FALHA: N√£o foi poss√≠vel criar pedido")
            return False
        
        # PASSO 2: Simular webhook Depix
        self.log_passo(2, "Simulando webhook Depix (confirma√ß√£o PIX)")
        if not self.simular_webhook_depix():
            print("‚ùå FALHA: Webhook Depix falhou")
            return False
        
        time.sleep(1)
        
        # PASSO 3: Atualizar status para pago
        self.log_passo(3, "Atualizando status para 'pago'")
        if not self.atualizar_status_pago():
            print("‚ùå FALHA: N√£o foi poss√≠vel atualizar status")
            return False
        
        time.sleep(1)
        
        # PASSO 4: Testar integra√ß√£o com bot
        self.log_passo(4, "Testando detec√ß√£o pelo bot")
        if not self.testar_integracao_bot():
            print("‚ùå FALHA: Bot n√£o respondeu")
            return False
        
        # PASSO 5: Aguardar processamento
        self.log_passo(5, "Aguardando processamento do bot")
        print("‚è≥ Aguardando 20 segundos para o bot processar...")
        time.sleep(20)
        
        # PASSO 6: Simular envio Bitcoin
        self.log_passo(6, "Simulando envio Bitcoin")
        if not self.simular_envio_bitcoin():
            print("‚ùå FALHA: Envio Bitcoin falhou")
            return False
        
        time.sleep(1)
        
        # PASSO 7: Verificar TXID na blockchain
        self.log_passo(7, "Verificando TXID na blockchain")
        self.verificar_txid_blockchain()  # N√£o para o teste se falhar
        
        time.sleep(1)
        
        # PASSO 8: Status final
        self.log_passo(8, "Verificando status final completo")
        sucesso_final = self.verificar_status_final()
        
        # RESUMO FINAL
        print("\n" + "=" * 80)
        print("üéØ RESUMO DO TESTE REALISTA")
        print("=" * 80)
        
        tempo_total = datetime.now() - self.teste_iniciado
        print(f"‚è±Ô∏è Tempo total: {tempo_total.total_seconds():.1f}s")
        print(f"üìã Pedido ID: {self.pedido_id}")
        print(f"üÜî Depix ID: {self.depix_id_real}")
        print(f"üí∞ Valor: R$ {self.valor_real}")
        print(f"‚ö° Lightning Address: {self.lightning_address_real}")
        print(f"üîó Blockchain TXID: {self.txid_bitcoin}")
        
        if sucesso_final:
            print("üéâ TESTE REALISTA: SUCESSO COMPLETO!")
            print("‚úÖ Fluxo completo funcionando de ponta a ponta")
        else:
            print("‚ö†Ô∏è TESTE REALISTA: PARCIAL")
            print("üì± Verificar detalhes no chat do Telegram")
        
        print("\nüìã DADOS PARA VERIFICA√á√ÉO MANUAL:")
        print(f"1. Interface web: {self.backend_url}/transacoes.php")
        print(f"2. Buscar por Depix ID: {self.depix_id_real}")
        print(f"3. Verificar TXID: {self.txid_bitcoin}")
        print(f"4. Chat Telegram: {self.chat_id}")
        print("=" * 80)
        
        return sucesso_final

if __name__ == "__main__":
    teste = TesteRealistaCompleto()
    teste.executar_teste_completo()
